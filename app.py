# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-gwOP-dLmydtAuljQpqQkhfMShvwfSwb
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from google_play_scraper import app, reviews, Sort
from textblob import TextBlob
import nltk
import gensim
from gensim import corpora
from wordcloud import WordCloud
import requests
import json
import re

# Initial setup for nltk
nltk.download('stopwords')
nltk.download('punkt')

# Function definitions
def scrape_app_data(package_name):
    try:
        app_info = app(package_name, lang='en', country='in')
        return app_info
    except Exception as e:
        st.error(f"Error in fetching app data: {str(e)}")
        return None

def scrape_app_reviews(package_name, review_count=10000):
    try:
        app_reviews, _ = reviews(package_name, lang='en', country='in', sort=Sort.NEWEST, count=review_count)
        df_reviews = pd.DataFrame(app_reviews)
        df_reviews.drop(columns=["userImage", "thumbsUpCount", "replyContent", "repliedAt"], inplace=True)
        df_reviews.insert(0, 'Serial Number', range(1, len(df_reviews) + 1))
        return df_reviews
    except Exception as e:
        st.error(f"Error fetching reviews: {str(e)}")
        return None

def scrape_app_reviews_positive(package_name, review_count=10000):
    try:
        app_reviews, _ = reviews(package_name, lang='en', country='in', sort=Sort.NEWEST, count=review_count, filter_score_with=5)
        df_reviews = pd.DataFrame(app_reviews)
        df_reviews.drop(columns=["userImage", "thumbsUpCount", "replyContent", "repliedAt"], inplace=True)
        df_reviews.insert(0, 'Serial Number', range(1, len(df_reviews) + 1))
        return df_reviews
    except Exception as e:
        st.error(f"Error fetching positive reviews: {str(e)}")
        return None

def scrape_app_reviews_negative(package_name, review_count=10000):
    try:
        app_reviews, _ = reviews(package_name, lang='en', country='in', sort=Sort.NEWEST, count=review_count, filter_score_with=1)
        df_reviews = pd.DataFrame(app_reviews)
        df_reviews.drop(columns=["userImage", "thumbsUpCount", "replyContent", "repliedAt"], inplace=True)
        df_reviews.insert(0, 'Serial Number', range(1, len(df_reviews) + 1))
        return df_reviews
    except Exception as e:
        st.error(f"Error fetching negative reviews: {str(e)}")
        return None

def get_sentiment(review):
    analysis = TextBlob(review)
    return analysis.sentiment.polarity

def create_wordcloud(text, title, color_map):
    wordcloud = WordCloud(width=800, height=400, background_color='white', colormap=color_map).generate(text)
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.imshow(wordcloud, interpolation='bilinear')
    ax.axis('off')
    ax.set_title(title)
    st.pyplot(fig)


# Function to call the Gemini API
def get_gemini_response(prompt):
    api_key = "AIzaSyAsDb1g2Eqruw8IyP9S3H9-MGGFiPXOGI8"  # Replace with your actual API key
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key={api_key}"
    headers = {'Content-Type': 'application/json'}
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    response = requests.post(url, headers=headers, data=json.dumps(data))
    return response.json()

def clean_and_format_response_for_users(response_json):
    try:
        response_text = response_json['candidates'][0]['content']['parts'][0]['text']
        response_text = re.sub(r'^\s+', '', response_text, flags=re.MULTILINE)
        response_text = re.sub(r'\s+$', '', response_text, flags=re.MULTILINE)
        response_text = re.sub(r'^-+\s*', '- ', response_text, flags=re.MULTILINE)
        response_text = re.sub(r':-', ':\n- ', response_text)
        response_text = re.sub(r' - ', ' ', response_text)
        response_text = re.sub(r'\n\n+', '\n\n', response_text)
        return response_text
    except (IndexError, KeyError):
        return "No insights available."

# Streamlit app layout
st.title('Google Play Store App Analysis Tool')

package_name = st.text_input("Enter the package name of the app (e.g., 'com.flipkart.android')")


# Project Overview Section
st.write("## Project Overview")
st.write("""
The App Feedback Analysis project is designed to extract and analyze user reviews from mobile applications on the Google Play Store.
Leveraging natural language processing (NLP) and machine learning techniques, this project provides valuable insights into user sentiment and key topics discussed in reviews.
By using libraries such as Pandas, NLTK, Gensim, and TextBlob, combined with visualization tools like Matplotlib and Seaborn, we create a comprehensive analysis pipeline.
The Gemini API is integrated to generate actionable insights from the analyzed data.
""")


# Output Understanding Section
st.write("## Output Overview")
st.write("""
CSV Files: Downloadable CSVs of all reviews, positive reviews, and negative reviews.
Visual Analytics: Word clouds and sentiment distribution plots that highlight the common themes and overall sentiment trends.
Generated Insights: Summarized insights using generative AI to help stakeholders understand key strengths and issues discussed in user feedback.
""")



if package_name:
    app_data = scrape_app_data(package_name)

    if app_data:
        # Scraping reviews
        df_reviews = scrape_app_reviews(package_name, review_count=1000)
        df_reviews_positive = scrape_app_reviews_positive(package_name, review_count=1000)
        df_reviews_negative = scrape_app_reviews_negative(package_name, review_count=1000)

        if df_reviews is not None:
            # Save CSV files for download
            csv_reviews = df_reviews.to_csv(index=False).encode('utf-8')
            csv_positive_reviews = df_reviews_positive.to_csv(index=False).encode('utf-8')
            csv_negative_reviews = df_reviews_negative.to_csv(index=False).encode('utf-8')

            st.download_button("Download All Reviews CSV", csv_reviews, "app_reviews.csv", "text/csv")
            st.download_button("Download Positive Reviews CSV", csv_positive_reviews, "app_reviews_positive.csv", "text/csv")
            st.download_button("Download Negative Reviews CSV", csv_negative_reviews, "app_reviews_negative.csv", "text/csv")

            # Sentiment Analysis
            df_reviews['sentiment'] = df_reviews['content'].apply(get_sentiment)
            df_reviews['sentiment_label'] = df_reviews['sentiment'].apply(lambda x: 'Positive' if x > 0 else ('Negative' if x < 0 else 'Neutral'))

            # Visualization: Sentiment Distribution
            st.write("### Sentiment Distribution")
            fig, ax = plt.subplots()
            sns.countplot(x='sentiment_label', data=df_reviews, ax=ax)
            ax.set_title('Sentiment Distribution')
            st.pyplot(fig)



            # LDA Topic Modeling
            stop_words = set(nltk.corpus.stopwords.words('english'))
            df_reviews_positive['tokens'] = df_reviews_positive['content'].apply(lambda x: [word for word in nltk.word_tokenize(x) if word.lower() not in stop_words])
            df_reviews_negative['tokens'] = df_reviews_negative['content'].apply(lambda x: [word for word in nltk.word_tokenize(x) if word.lower() not in stop_words])

            dictionary_positive = corpora.Dictionary(df_reviews_positive['tokens'])
            corpus_positive = [dictionary_positive.doc2bow(text) for text in df_reviews_positive['tokens']]
            dictionary_negative = corpora.Dictionary(df_reviews_negative['tokens'])
            corpus_negative = [dictionary_negative.doc2bow(text) for text in df_reviews_negative['tokens']]

            lda_model_positive = gensim.models.ldamodel.LdaModel(corpus_positive, num_topics=5, id2word=dictionary_positive, passes=10)
            lda_model_negative = gensim.models.ldamodel.LdaModel(corpus_negative, num_topics=5, id2word=dictionary_negative, passes=10)

            formatted_positive_topics = [topic for _, topic in lda_model_positive.print_topics(-1)]
            formatted_negative_topics = [topic for _, topic in lda_model_negative.print_topics(-1)]

            # Generative AI prompts
            input_prompt_positive = (
                "We have conducted a thorough analysis of positive app reviews using Latent Dirichlet Allocation (LDA), resulting in the following topics:\n\n"
                + "\n".join(formatted_positive_topics) + "\n\n"
                "Your task is to provide actionable insights based on these topics. Please consider the following points:\n"
                "1. Identify specific strengths and positive attributes highlighted in each topic.\n"
                "2. Suggest strategies for enhancing customer satisfaction based on the positive aspects mentioned.\n"
                "3. Recommend ways to leverage these positive attributes in marketing and user engagement initiatives.\n"
                "4. Provide concrete examples or actions that could be taken to further capitalize on these strengths.\n"
                "Please respond with a structured format, including clear headings for each topic such that it is readable by people."
            )

            input_prompt_negative = (
                "In our analysis of negative app reviews, we have identified the following key topics through Latent Dirichlet Allocation (LDA):\n\n"
                + "\n".join(formatted_negative_topics) + "\n\n"
                "Your task is to provide actionable insights based on these topics. Please consider the following points:\n"
                "1. Identify specific weaknesses and negative attributes highlighted in each topic.\n"
                "2. Suggest strategies for enhancing customer satisfaction based on the negative aspects mentioned.\n"
                "3. Recommend ways to rectify these negative attributes to increase marketing and user engagement initiatives.\n"
                "4. Provide concrete examples or actions that could be taken to further improve on these weaknesses.\n"
                "Please respond with a structured format, including clear headings for each topic such that it is readable by people."
            )

            st.write("#### Generating Insights for Positive Reviews...")
            response_positive = get_gemini_response(input_prompt_positive)
            if response_positive:
                formatted_positive = clean_and_format_response_for_users(response_positive)
                st.write("Positive Insights Response:")
                st.text(formatted_positive)

            st.write("#### Generating Insights for Negative Reviews...")
            response_negative = get_gemini_response(input_prompt_negative)
            if response_negative:
                formatted_negative = clean_and_format_response_for_users(response_negative)
                st.write("Negative Insights Response:")
                st.text(formatted_negative)


            # Word Clouds
            positive_reviews_text = ' '.join(df_reviews[df_reviews['sentiment_label'] == 'Positive']['content'])
            negative_reviews_text = ' '.join(df_reviews[df_reviews['sentiment_label'] == 'Negative']['content'])

            # Displaying word clouds
            st.write("### Positive Reviews Word Cloud")
            create_wordcloud(positive_reviews_text, "Positive Reviews Word Cloud", color_map='Greens')

            st.write("### Negative Reviews Word Cloud")
            create_wordcloud(negative_reviews_text, "Negative Reviews Word Cloud", color_map='Reds')